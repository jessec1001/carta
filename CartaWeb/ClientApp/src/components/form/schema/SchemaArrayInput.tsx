import { FunctionComponent } from "react";
import { useControllableState } from "hooks";
import classNames from "classnames";
import {
  arraySubschema,
  JsonArraySchema,
  JsonArraySchemaWidgets,
  schemaDefault,
  ValidationError,
} from "library/schema";
import { IconAddButton, IconRemoveButton } from "components/buttons";
import { EmptySymbol } from "components/ui/symbols";
import FormGroup from "../FormGroup";
import SchemaBaseInput, { SchemaTypedInputProps } from "./SchemaBaseInput";

/** The props used for the {@link SchemaArrayInput} component. */
type SchemaArrayInputProps = SchemaTypedInputProps<
  JsonArraySchema,
  any[],
  JsonArraySchemaWidgets
>;

/** The props used for the {@link SchemaArrayItemInput} component. */
interface SchemaArrayItemInputProps {
  addable?: boolean;
  removeable?: boolean;

  onAdd?: () => void;
  onRemove?: () => void;
}

/** A component that inputs an array with entries based on a schema as a list. */
const SchemaArrayInput: FunctionComponent<SchemaArrayInputProps> = ({
  schema,
  widget,
  error,
  value,
  onChange,
  children,
  ...props
}) => {
  // We allow the component to have an optionally controlled value.
  const [actualValue, setValue] = useControllableState(
    () => schemaDefault(schema, value),
    value,
    onChange
  );

  // Create event handlers.
  // This event handler updates the object through a single entry change.
  const handleChangeEntry = (index: number, value: any) => {
    const nextValue = [...actualValue];
    nextValue[index] = value;
    setValue(nextValue);
  };
  // This event handler adds a new entry with a default value generated by the subschema.
  // The added entry is added at the specified index.
  const handleAddEntry = (index: number) => {
    const subschema = arraySubschema(schema, actualValue.length);
    const addedValue = schemaDefault(subschema);
    const nextValue = [...actualValue];
    nextValue.splice(index, 0, addedValue);
    setValue(nextValue);
  };
  // This event handler removes an existing entry.
  // The removed entry is removed at the specified index.
  const handleRemoveEntry = (index: number) => {
    const nextValue = [...actualValue];
    nextValue.splice(index, 1);
    setValue(nextValue);
  };

  // By default, we should display this input as a list.
  let uiWidget: JsonArraySchemaWidgets = widget ?? JsonArraySchemaWidgets.List;
  if (schema["ui:widget"] !== undefined) uiWidget = schema["ui:widget"];

  // Display based on the decided upon widget.
  switch (uiWidget) {
    case JsonArraySchemaWidgets.List:
      // Extract whether we can add and remove entries.
      // Adding adds an entry after the current entry.
      // Removing removes the current entry.
      let addable: boolean =
        !Array.isArray(schema.items) &&
        (schema.maxItems === undefined || schema.maxItems > actualValue.length);
      let removeable: boolean =
        !Array.isArray(schema.items) &&
        (schema.minItems === undefined || schema.minItems < actualValue.length);

      return (
        <div className={classNames("form-container", { error })}>
          {actualValue.map((subvalue, index) => {
            // Deconstruct error and create suberror if necessary.
            let suberror: ValidationError | undefined = undefined;
            let suberrorKey: number | undefined = undefined;
            if (error !== undefined) {
              const suberrorTrace = [...error.trace];
              suberrorKey =
                error === undefined
                  ? undefined
                  : (suberrorTrace.shift() as number | undefined);
              suberror = new ValidationError(suberrorTrace, error.message);
            }

            // We need to compute the subschema at each value to display the value correctly.
            const subschema = arraySubschema(schema, index);

            // We wrap the base input in an array item format so we can inject
            // add and remove entry buttons.
            return (
              <FormGroup
                error={
                  suberrorKey === index && suberror?.trace?.length === 0
                    ? suberror
                    : undefined
                }
                title={subschema.title}
                description={subschema.description}
                key={index}
              >
                <SchemaArrayItemInput
                  addable={addable}
                  removeable={removeable}
                  onAdd={() => handleAddEntry(index + 1)}
                  onRemove={() => handleRemoveEntry(index)}
                >
                  <SchemaBaseInput
                    schema={subschema}
                    error={suberrorKey === index ? suberror : undefined}
                    value={subvalue}
                    onChange={(value) => handleChangeEntry(index, value)}
                    {...props}
                  />
                </SchemaArrayItemInput>
              </FormGroup>
            );
          })}
          {actualValue.length === 0 && (
            <SchemaArrayItemInput
              addable={addable}
              onAdd={() => handleAddEntry(0)}
            >
              <EmptySymbol />
            </SchemaArrayItemInput>
          )}
        </div>
      );
    default:
      return null;
  }
};

/** A component that inputs an array item with add and/or remove buttons. */
const SchemaArrayItemInput: FunctionComponent<SchemaArrayItemInputProps> = ({
  children,
  addable,
  removeable,
  onAdd,
  onRemove,
}) => {
  return (
    <div className="form-spaced-group">
      <div>{children}</div>
      {(addable || removeable) && (
        <div className="no-grow">
          {addable && <IconAddButton onClick={onAdd} />}
          {removeable && <IconRemoveButton onClick={onRemove} />}
        </div>
      )}
    </div>
  );
};

// Export React component and props.
export default SchemaArrayInput;
export { SchemaArrayItemInput };
export type { SchemaArrayInputProps, SchemaArrayItemInputProps };
