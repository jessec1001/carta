using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using CartaCore.Graphs;
using CartaCore.Operations;
using NUnit.Framework;

namespace CartaTest.Operations
{
    /// <summary>
    /// Tests a workflow that loads data from a CSV file stored at a particular URL.
    /// </summary>
    public class TestParseCsvWorkflow
    {
        /// <summary>
        /// Tests that a CSV file containing information about the locations of cities can be read from a URL into a
        /// graph dataset.
        /// </summary>
        [Test]
        public async Task TestParseCsvCities()
        {
            // The following workflow (diagram) is generated by this test code.
            /*
                Input (Url) -> Url Stream -> Parse CSV -> Output (Graph)
            */
            // Equivalently, this workflow could be represented more standardly as:
            /*
                Workflow
                ++++++++++++++++++++++++++++++++++++++++++++++++++
                Operation #1 (Input)
                ["Url" ===========> Name                         ]
                [                               Value --------- A]

                Operation #2 (URL Stream)
                [A ---------------> Url                          ]
                [                               Stream -------- B]

                Operation #3 (CSV Parser)
                [B ---------------> Stream                       ]
                ["," =============> Delimiter                    ]
                [true ============> ContainsHeader               ]
                [true ============> InferTypes                   ]
                [                               Graph --------- C]

                Operation #4 (Output)
                [C ---------------> Value                        ]
                ["Graph" =========> Name                         ]
            */

            // Define the operations required.
            #region Operations
            InputOperation<string> opInputUrl = new()
            {
                Id = "1",
                DefaultsTyped = new() { Name = "Url" }
            };
            StreamUrlOperation opStreamUrl = new()
            {
                Id = "2",
            };
            ParseCsvOperation opParseCsv = new()
            {
                Id = "3",
                DefaultsTyped = new()
                {
                    Delimiter = ",",
                    ContainsHeader = true,
                    InferTypes = true
                }
            };
            OutputOperation<Graph> opOutputGraph = new()
            {
                Id = "4",
                DefaultsTyped = new() { Name = "Graph" }
            };
            #endregion

            // Define the connections required.
            #region Connections
            WorkflowOperationConnection connUrlToStream = new()
            {
                Source = new() { Operation = opInputUrl.Id, Field = nameof(InputOperationOut<string>.Value) },
                Target = new() { Operation = opStreamUrl.Id, Field = nameof(StreamUrlOperationIn.Url) }
            };
            WorkflowOperationConnection connStreamToCsv = new()
            {
                Source = new() { Operation = opStreamUrl.Id, Field = nameof(StreamUrlOperationOut.Stream) },
                Target = new() { Operation = opParseCsv.Id, Field = nameof(ParseCsvOperationIn.Stream) }
            };
            WorkflowOperationConnection connCsvToGraph = new()
            {
                Source = new() { Operation = opParseCsv.Id, Field = nameof(ParseCsvOperationOut.Graph) },
                Target = new() { Operation = opOutputGraph.Id, Field = nameof(OutputOperationIn<Graph>.Value) }
            };
            #endregion

            // Create the workflow operation.
            WorkflowOperation opWorkflow = new(
                new Operation[]
                {
                    opInputUrl,
                    opStreamUrl,
                    opParseCsv,
                    opOutputGraph
                },
                new WorkflowOperationConnection[]
                {
                    connUrlToStream,
                    connStreamToCsv,
                    connCsvToGraph
                }
            )
            { Id = "workflow" };

            // Check that an input to the workflow is correctly processed and produces expected results.
            string csvUrl = "https://people.sc.fsu.edu/~jburkardt/data/csv/cities.csv";
            Dictionary<string, object> input = new()
            {
                ["Url"] = csvUrl
            };
            Dictionary<string, object> output = new();
            OperationJob job = new(opWorkflow, "job", input, output);
            await opWorkflow.Perform(job);

            // Get the graph from the output.
            Assert.Contains("Graph", output.Keys);
            Assert.IsInstanceOf<MemoryGraph>(output["Graph"]);
            MemoryGraph graph = output["Graph"] as MemoryGraph;

            // Check that there is the correct number of samples.
            Assert.AreEqual(128, await graph.GetVertices().CountAsync());

            // Check that there are the correct properties and property types.
            await foreach (IVertex ivertex in graph.GetVertices())
            {
                // Assert that the vertex is of base type.
                Vertex vertex = ivertex as Vertex;
                Assert.IsNotNull(vertex);

                // Assert property names.
                string[] propertyNames = vertex.Properties
                    .Select(pair => pair.Key)
                    .ToArray();
                Assert.Contains("LatD", propertyNames); // Latitude Degrees
                Assert.Contains("LatM", propertyNames); // Latitude Minutes
                Assert.Contains("LatS", propertyNames); // Latitude Seconds
                Assert.Contains("NS", propertyNames);   // North/South
                Assert.Contains("LonD", propertyNames); // Longitude Degrees
                Assert.Contains("LonM", propertyNames); // Longitude Minutes
                Assert.Contains("LonS", propertyNames); // Longitude Seconds
                Assert.Contains("EW", propertyNames);   // East/West
                Assert.Contains("City", propertyNames);
                Assert.Contains("State", propertyNames);

                // Assert property types.
                object latD = vertex.Properties["LatD"].Value;
                object latM = vertex.Properties["LatM"].Value;
                object latS = vertex.Properties["LatS"].Value;
                object ns = vertex.Properties["NS"].Value;
                object city = vertex.Properties["City"].Value;
                object state = vertex.Properties["State"].Value;
                Assert.IsInstanceOf<int>(latD);
                Assert.IsInstanceOf<int>(latM);
                Assert.IsInstanceOf<int>(latS);
                Assert.IsInstanceOf<string>(ns);
                Assert.IsInstanceOf<string>(city);
                Assert.IsInstanceOf<string>(state);
            }

            // Check some specific values.
            Vertex wichitaVertex = await graph
                .GetVertices()
                .FirstAsync(vertex => (string)vertex.Properties["City"].Value == "Wichita");
            Assert.AreEqual(37, (int)wichitaVertex.Properties["LatD"].Value);
            Assert.AreEqual(97, (int)wichitaVertex.Properties["LonD"].Value);
            Assert.AreEqual("KS", (string)wichitaVertex.Properties["State"].Value);

            Vertex scrantonVertex = await graph
                .GetVertices()
                .FirstAsync(vertex => (string)vertex.Properties["City"].Value == "Scranton");
            Assert.AreEqual(41, (int)scrantonVertex.Properties["LatD"].Value);
            Assert.AreEqual(75, (int)scrantonVertex.Properties["LonD"].Value);
            Assert.AreEqual("PA", (string)scrantonVertex.Properties["State"].Value);
        }
    }
}